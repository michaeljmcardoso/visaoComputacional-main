# -*- coding: utf-8 -*-
"""Modelo.ipynb (Colab)

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ggHJVAm_6cPLgcs6twg1YToUXb_J6pFr
"""
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import confusion_matrix
from sklearn.metrics import classification_report
from sklearn.metrics import accuracy_score
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout
from tensorflow.keras.utils import to_categorical


# Carregando o arquivo CSV
csvPath = '/home/import_michael/Documentos/Backup/visaoComputacional/ckextended.csv'
df = pd.read_csv(csvPath)

"""
Utilizamos o CK+: Dataset de expressões faciais.[kaggle](https://www.kaggle.com/datasets/davilsena/ckdataset)
para carregar nosso modelos, que contém sequências de expressões faciais dinâmicas, rotuladas com emoções básicas.
"""

# Convertendo as strings de pixels em arrays numpy
df['pixels'] = df['pixels'].apply(lambda x: np.array(x.split(), dtype="float32"))

# Separando os dados em imagens e rótulos
images = np.vstack(df['pixels'].values)
images = images.reshape(-1, 48, 48, 1)  # Assumindo imagens 48x48 (ajuste conforme necessário)
labels = np.array(df['emotion'])

# Convertendo as etiquetas para números (0 a 6)
label_encoder = LabelEncoder()
labels = label_encoder.fit_transform(labels)

# Ajustando os rótulos para garantir que estejam no intervalo [0, 6]
labels = np.clip(labels, 0, 6)

# Dividindo os dados em conjuntos de treinamento e teste
trainImages, testImages, trainLabels, testLabels = train_test_split(images, labels, test_size=0.2, random_state=42)

# Verificando as formas dos conjuntos
print("Shape of train_images:", trainImages.shape)
print("Shape of test_images:", testImages.shape)
print("Shape of train_labels:", trainLabels.shape)
print("Shape of test_labels:", testLabels.shape)

# Arquitetura do Modelo
model = Sequential()

model.add(Conv2D(32, (3, 3), activation='relu', input_shape=(48, 48, 1)))
model.add(MaxPooling2D((2, 2)))

model.add(Conv2D(64, (3, 3), activation='relu'))
model.add(MaxPooling2D((2, 2)))

model.add(Conv2D(128, (3, 3), activation='relu'))
model.add(MaxPooling2D((2, 2)))

model.add(Flatten())
model.add(Dense(128, activation='relu'))
model.add(Dropout(0.5))  # Adicionando dropout para regularização
model.add(Dense(7, activation='softmax'))  # Saída com 7 neurônios para as 7 emoções

# converter rótulos (labels) categóricos em codificação one-hot.
train_labels_one_hot = to_categorical(trainLabels) # Aplica a codificação one-hot aos rótulos de treinamento (train_labels).
test_labels_one_hot = to_categorical(testLabels) #  Aplica a mesma codificação one-hot aos rótulos de teste (test_labels).

# Compilação do Modelo
model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])

# Treinamento do Modelo
history = model.fit(trainImages, trainLabels, epochs=15, validation_data=(testImages, testLabels))

# Salvando o modelo no Google Drive
model.save('/home/import_michael/Documentos/Backup/visaoComputacional/modeloDeReconhecimentoFacialDeEmocoes.h5')

"""
Nesse trecho de código, 
o modelo treinado é usado para fazer previsões nas imagens de teste (test_images). 
A função predict é aplicada ao modelo para obter as previsões para cada imagem no conjunto de teste.
"""

# Avaliação do Modelo
def evaluate_model(model, testImages, testLabels, label_encoder, num_classes):
    # Fazendo previsões
    predictions = np.argmax(model.predict(testImages), axis=1)

    # Matriz de Confusão
    cm = confusion_matrix(testLabels, predictions)
    plt.figure(figsize=(8, 6))
    sns.heatmap(cm, annot=True, fmt='g', cmap='Reds', xticklabels=label_encoder.classes_, yticklabels=label_encoder.classes_)
    plt.xlabel('Rótulos previstos')
    plt.ylabel('Rótulos verdadeiros')
    plt.show()

    # Relatório de Classificação
    print("Relatório de Classificação:")
    target_names = [str(label) for label in range(num_classes)]  # Usamos range para gerar [0, 1, 2, ..., num_classes-1]
    print(classification_report(testLabels, predictions, target_names=target_names, zero_division=1))

    # Acurácia
    accuracy = accuracy_score(testLabels, predictions)
    print("Precisão ou Acurácia do Modelo:", "{:.2%}".format(accuracy)) # formata para duas casas decimais
 
# chamada da função de avaliação do modelo
evaluate_model(model, testImages, testLabels, label_encoder, num_classes=7)
